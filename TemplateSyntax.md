# Introduction #
For Web designers and other non-programmers, that must check or edit the _templates_, is important that the _template syntax rules_ not change. And for programmers: reusability and portability are central aspects of templates.

As remembered by [J. Hunter 12 years ago](http://www.servlets.com/soapbox/problems-jsp.html), "<i>No specification exists for how a template engine should behave</i>". Today (2012s) we can found mature standards for big/complex templates, like [XSLT](http://www.w3.org/TR/xslt), and for little, as [sprintf](http://en.wikipedia.org/wiki/Printf_format_string), but no "general specification" as Hunter wanted.

Here, we will specify "what is a template", "what is a template engine" and <u>the unified syntax of placeholders and formatters of any-size <i>template systems</i></u>.
There are some reasons for suppose that here we can supply a "more standard plataform independent" syntax:
  * The use of the well-known (since C89) _sprintf_ standards.
  * The  _sprintf_  flexibilization enables the use in  "whole document templates", and gain compatibility to other popular conventions (like PHP or XSLT placeholders).
  * As a "middle size algorithm", extending _sprintf_ usability, it avoids the use of complex and bigger frameworks (of more complete template languages), like XSLT.
  * This algorithm can "migrate to XSLT" (preserving some syntax conventions) as [registerFunctions](http://php.net/manual/en/xsltprocessor.registerphpfunctions.php).
  * This definition is under construction, you can collaborate!

## Basic concepts ##
Practical programmers have a consensus: if <i>X</i> is a placeholder and "Hello <i>X</i>!" is a template string, then "Hello world!" and "Hello Jonh!" are strings generated by "<i>X</i>=world" and "<i>X</i>=Jonh".
That is: a <i>template</i> is a string with placeholders, not a function. And a <i>template processor</i> (also named <i>template engine</i>) process the template string, them can be modeled by a function.

Definitions:
  * **template**: is a "short or whole document" string, that have placeholders (and/or formatting directives) into. It is an input to the _template processor_.
  * **template processor** is a function that performs the placeholder substitution. The _template processor_ have two inputs, the template (_T_), and the input data (_X_); them is a function _f_(_T_,_X_).
  * **template data** is the input data, _X_, of the template _T_, compatible with the expected placeholders of _T_.
  * **template system** is a system composed by a _template processor_,  the _template syntax conventions_, and the _template data structure conventions_.

Here, in this project, this page specify the _template syntax conventions_; and the algorithm specifications, like [the PHP one](PHP.md),  show alternatives to _template processors_ and  _template data structure conventions_.

# Main conventions #
The "default (suggested) syntax" is
| **Syntax** | **Example** |
|:-----------|:------------|
| {$ argument\_index}| {$3} |
| {$ argument\_name}| {$surname} |
| {$ argument | format}| {$n|2d} |

The <i>argument_index</i> is a decimal integer indicating the position of the argument in the argument list (a usual string array). The first argument is referenced by "1", the second by "2", etc.

The <i>argument_name</i> is a case-sensitive alphanumerical string indicating the "variable name" of the argument in a associative array.

_Format_ is a <tt>sprintf</tt>-like mini-language. All programming languages (like Java, Perl, PHP, Python, etc.) offers this kind of formatter, but they can differ. Example: [Java](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Formatter.html#syntax) and [PHP](http://www.php.net/manual/en/function.sprintf.php) have similar ones, [Python](http://docs.python.org/library/string.html#formatstrings) differ in some details.

The general (basic) _format_ syntax is:

> `[flags`]`[width`]`[.precision`]conversion

but, for more details you must to check your _smallest-template-system_ implementation. The main ones are listed here, at References section.
The usual conventions are,

  * The optional _flags_ is a set of characters that modify the output format. The set of valid flags depends on the conversion.

  * The optional _width_ is a non-negative decimal integer indicating the minimum number of characters to be written to the output.

  * The optional _precision_ is a non-negative decimal integer usually used to restrict the number of characters. The specific behavior depends on the conversion.

  * The required _conversion_ is a character indicating how the argument should be formatted. The set of valid conversions for a given argument depends on the argument's data type.


## Template examples ##

Template syntax on default conventions:
| **Template**    | **Data** |  **Output** |
|:----------------|:---------|:------------|
| _Hello {$0}!_ | world | Hello world!|
| _Hello {$0}!_ | Maria | Hello Maria!|
| _Hello {$name}!_ | Jonh | Hello Jonh!|
| _The number is {$n|2.2f}._ | 3.1416 | The number is 3.14. |

Changing some default conventions: prefix=%% and not to use {}.

| **Template**    | **Data** |  **Output** |
|:----------------|:---------|:------------|
| _Hello %%!_ | world | Hello world!|
| _Hello %%name!_ | Jonh | Hello Jonh!|
| _The number is %%n|2.2f ._ | 3.1416 | The number is 3.14 . |

The last one show a typical syntax conflict: if there is no blank space, the string  "2.2f." can be interpreted as format. Enclosing by "{}" avoid conflicts.

# Alternative syntax #
An "alternative for default syntax" is necessary:  to prevent syntax collisions, to avoid need for espaping characters,  or to adhere to your framework conventions.

We adopt here a flexible formatting syntax similar to the [Python string-formatting](http://docs.python.org/library/stdtypes.html#string-formatting).

## Simple placeholders ##
There are many possible conventions for your template syntax,

| **Syntax** | **Example** |
|:-----------|:------------|
| prefix| %% |
| {prefix}| {%%} |
| prefix argument\_index| %%3 |
| prefix argument\_name| %%surname |
| {prefix argument} | {%%x} |

## Formatted placeholders ##

Alternatives to the "{$ argument | format}" (ex. "<tt>{$x|s}</tt>"),

| **Syntax** | **Example** |
|:-----------|:------------|
| prefix separator format| %%|s |
| {prefix separator format}| {%%|s} |
| prefix argument separator format| %%x|s |

# Extensions #
Some extendibility for formatting options is possible, but we not recommend add more processing, the suggestion is to supply processed data to the template.

If some extendibility is necessary, the syntax to extension is,

| **Syntax** | **Example** |
|:-----------|:------------|
| {$ argument | format | piped\_function}| {$n|2d|render} |
| {$ argument ! piped\_function | format}| {$n!transform|2d} |

A typical use, where it is necessary, is the conditional pluralization:

| {$substative!pluralize($n)} |
|:----------------------------|

Possible outputs of a <tt>"Eating {$n} {$food!pluralize($n)}"</tt> template: "Eating 1 octopus", "Eating 3 octopuses".

# References #

  * [vsprintf PHP function](http://www.php.net/manual/en/function.vsprintf.php).

  * [String.format Java function](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Formatter.html#syntax)

  * [Python string-formatting](http://docs.python.org/library/stdtypes.html#string-formatting)